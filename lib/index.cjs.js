"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class t{constructor(t=0,s=0){this._x=t,this._y=s}get x(){return this._x}set x(t){this._x=t}get y(){return this._y}set y(t){this._y=t}get magnitude(){return Math.sqrt(Math.pow(this._x,2)+Math.pow(this._y,2))}set(t,s){this._x=t,this._y=s}copy(t){this.set(t.x,t.y)}equals(t){return this._x===t.x&&this._y===t.y}clone(){return new t(this._x,this._y)}distance(t){return Math.sqrt(Math.pow(this._x-t.x,2)+Math.pow(this._y-t.y,2))}static add(t,s,i){return t.set(s.x+i.x,s.y+i.y),t}static subtract(t,s,i){return t.set(s.x-i.x,s.y-i.y),t}static unit(t,s){return 0===s.magnitude?t.set(0,0):t.set(s.x/s.magnitude,s.y/s.magnitude),t}static normal(t,s){return t.set(-s.y,s.x),this.unit(t,t)}static scale(t,s,i){return t.set(s.x*i,s.y*i),t}static dot(t,s){return t.x*s.x+t.y*s.y}static cross(t,s){return t.x*s.y-t.y*s.x}static round(t,s){return t.set(Math.round(s.x),Math.round(s.y)),t}}const s=(t,s)=>Math.round(t*Math.pow(10,s))/Math.pow(10,s);exports.Rectangle=class{constructor(s,i,e,h){this._position=new t,this._center=new t,this._width=0,this._height=0,this.set(s,i,e,h)}get x(){return this._position.x}set x(t){this._position.set(t,this._position.y)}get y(){return this._position.y}set y(t){this._position.set(this._position.x,t)}get x1(){return this._position.x+this._width}get y1(){return this._position.y+this._height}get position(){return this._position}set position(t){this._position.set(t.x,t.y)}get width(){return this._width}set width(t){this._width=t}get height(){return this._height}set height(t){this._height=t}get center(){return this._center.set(this.x+this.width/2,this.y+this.height/2),this._center}set(t,s,i,e){this._position.set(t,s),this._width=i,this._height=e}equals(t){return this.position.equals(t.position)&&this.width===t.width&&this.height===t.height}copy(t){this.set(t.x,t.y,t.width,t.height)}overlappingRectangle(t){return this.x1>=t.x&&this.x<=t.x1&&this.y1>=t.y&&this.y<=t.y1}},exports.Rotation=class{constructor(s=null,i=null){this._degrees=0,this._radians=0,this._direction=new t,s?this.radians=s:i&&(this.degrees=i)}set degrees(t){this._degrees=t,this._radians=t*Math.PI/180,this.updateDirection()}get degrees(){return this._degrees}set radians(t){this._radians=t,this._degrees=180*t/Math.PI,this.updateDirection()}get radians(){return this._radians}get direction(){return this._direction}updateDirection(){this._direction.set(Math.cos(this._radians),Math.sin(this._radians))}},exports.Vector2=t,exports.between=(t,s,i)=>t>=s&&t<=i,exports.clamp=(t,s,i)=>Math.min(i,Math.max(s,t)),exports.fixedRound=s,exports.randomFloat=(t,i,e=2)=>s(Math.random()*(i-t)+t,e),exports.randomInt=(t,s)=>Math.round(Math.random()*(s-t))+t,exports.range=(t,s,i=1)=>{const e=[];for(let h=t;h<=s;h+=i)e.push(h);return e};
